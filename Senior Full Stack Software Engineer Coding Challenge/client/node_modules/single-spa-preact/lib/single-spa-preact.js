"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = singleSpaPreact;

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var defaultOpts = {
  // required opts
  preact: null,
  rootComponent: null,
  domElementGetter: null
};

function singleSpaPreact(userOpts) {
  if (_typeof(userOpts) !== 'object') {
    throw new Error("single-spa-preact requires a configuration object");
  }

  var opts = _objectSpread({}, defaultOpts, {}, userOpts);

  if (!opts.preact) {
    throw new Error("single-spa-preact must be passed opts.preact");
  }

  if (!opts.rootComponent) {
    throw new Error("single-spa-preact must be passed opts.rootComponent");
  }

  if (!opts.domElementGetter) {
    throw new Error("single-spa-preact must be passed opts.domElementGetter function");
  }

  return {
    bootstrap: bootstrap.bind(null, opts),
    mount: mount.bind(null, opts),
    unmount: unmount.bind(null, opts)
  };
}

function bootstrap(opts) {
  return Promise.resolve();
}

function mount(opts, props) {
  return new Promise(function (resolve, reject) {
    opts.renderedNode = opts.preact.render(opts.preact.h(opts.rootComponent, props, null), getRootDomEl(opts));
    resolve();
  });
}

function unmount(opts) {
  return new Promise(function (resolve, reject) {
    opts.preact.render('', // see https://github.com/developit/preact/issues/53
    getRootDomEl(opts), opts.renderedNode);
    delete opts.renderedNode;
    resolve();
  });
}

function getRootDomEl(opts) {
  var el = opts.domElementGetter();

  if (!el) {
    throw new Error("single-spa-preact: domElementGetter function did not return a valid dom element");
  }

  return el;
}
//# sourceMappingURL=single-spa-preact.js.map